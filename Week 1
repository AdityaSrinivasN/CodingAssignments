/* Kth row of pascals triangle */

vector<int> Solution::getRow(int k) {
    vector<int> v(k+1);
    if(k==0){
        v[0]=1;
        return v;
    }
    int c=1;
    v[0]=c;
    for(int j=1;j<=k;j++){
        v[j]=c*(k-j+1)/j;
        c=v[j];
    }
    return v;
}

/* Climbing Stairs */

def climbStairs(n):
 steps = []
 steps.append(1)
 steps.append(2)
 for i in range(2, n):
  steps.append(f[i - 1] + f[i - 2])
 return steps[n - 1]
n=3
print(climbStairs(n))


/* Min Max Stocks */
class Solution {
public:
    int maxProfit(vector<int> &prices) {
        return maxProfit(prices, 0, prices.size());
    }
private:
    int maxProfit(vector<int> &prices, int lo, int hi) {
        if (hi - lo < 2) return 0;
        
        int mid = lo + (hi - lo) / 2;
        int left = maxProfit(prices, lo, mid);
        int right = maxProfit(prices, mid, hi);
        
        int buy = prices[lo];
        for (int i = lo + 1; i < mid; i++) {
            if (prices[i] < buy) buy = prices[i];
        }
        
        int sell = prices[mid];
        for (int i = mid + 1; i < hi; i++) {
            if (prices[i] > sell) sell = prices[i];
        }
        
        if (sell > buy) {
            int profit = sell - buy;
            return max(left, max(profit, right));
        } else {
            return max(left, right);
        }
    }
}

/* Repeat number and missing array */
vector < int >Solution::repeatedNumber (const vector < int >&arr) {
    /* Will hold xor of all elements and numbers from 1 to n */
    int xor1;

    /* Will have only single set bit of xor1 */
    int set_bit_no;

    int i;
    int x = 0; // missing
    int y = 0; // repeated
    int n = arr.size();

    xor1 = arr[0];

    /* Get the xor of all array elements */
    for (i = 1; i < n; i++)
        xor1 = xor1 ^ arr[i];

    /* XOR the previous result with numbers from 1 to n */
    for (i = 1; i <= n; i++)
        xor1 = xor1 ^ i;

    /* Get the rightmost set bit in set_bit_no */
    set_bit_no = xor1 & ~(xor1 - 1);

    /* Now divide elements into two sets by comparing a rightmost set bit
       of xor1 with the bit at the same position in each element.
       Also, get XORs of two sets. The two XORs are the output elements.
       The following two for loops serve the purpose */

    for (i = 0; i < n; i++) {
        if (arr[i] & set_bit_no)
            /* arr[i] belongs to first set */
            x = x ^ arr[i];

        else
            /* arr[i] belongs to second set */
            y = y ^ arr[i];
    }

    for (i = 1; i <= n; i++) {
        if (i & set_bit_no)
            /* i belongs to first set */
            x = x ^ i;

        else
            /* i belongs to second set */
            y = y ^ i;
    }

    // NB! numbers can be swapped, maybe do a check ?
    int x_count = 0;
    for (int i=0; i<n; i++) {
        if (arr[i]==x)
            x_count++;
    }
    
    if (x_count==0)
        return {y, x};
    
    return {x, y};
}

/* N children */
public class Solution {
    public int candy(int[] ratings) {
        int sum = 0;
        if (ratings.length == 0)
            return sum;
        int[] lc = new int[ratings.length];
        int[] rc = new int[ratings.length];
        for (int i = 0 ; i < ratings.length; i++)
            lc[i] = rc[i] = 1;
        for (int i = 0 ; i < ratings.length-1; i++){
            if (ratings[i] < ratings[i+1])
                lc[i+1] = lc[i] + 1;
        }
        for (int i = ratings.length-1 ; i > 0 ; i--){
            if (ratings[i-1] > ratings[i])
                rc[i-1] = rc[i] + 1;
        }
        for (int i = 0 ; i < ratings.length ; i++){
            sum += max(lc[i] , rc[i]);
        }
        return sum;
    }
    
    private int max(int a , int b){
        return a > b ? a : b;
    }
}
